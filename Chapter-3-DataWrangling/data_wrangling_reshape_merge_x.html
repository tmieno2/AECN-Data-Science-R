<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data wrangling with tidyverse: Reshaping and Merging</title>
    <meta charset="utf-8" />
    <meta name="author" content="AECN 396/896-002" />
    <script src="data_wrangling_reshape_merge_x_files/header-attrs/header-attrs.js"></script>
    <link href="data_wrangling_reshape_merge_x_files/tile-view/tile-view.css" rel="stylesheet" />
    <script src="data_wrangling_reshape_merge_x_files/tile-view/tile-view.js"></script>
    <link href="data_wrangling_reshape_merge_x_files/animate.css/animate.xaringan.css" rel="stylesheet" />
    <link href="data_wrangling_reshape_merge_x_files/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="data_wrangling_reshape_merge_x_files/panelset/panelset.css" rel="stylesheet" />
    <script src="data_wrangling_reshape_merge_x_files/panelset/panelset.js"></script>
    <script src="data_wrangling_reshape_merge_x_files/clipboard/clipboard.min.js"></script>
    <link href="data_wrangling_reshape_merge_x_files/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="data_wrangling_reshape_merge_x_files/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Code","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Data wrangling with <code>tidyverse</code>: Reshaping and Merging
]
.author[
### AECN 396/896-002
]

---

class: middle


















&lt;style type="text/css"&gt;
@media print {
  .has-continuation {
    display: block !important;
  }
}

.remark-slide-content.hljs-github h1 {
  margin-top: 5px;  
  margin-bottom: 25px;  
}

.remark-slide-content.hljs-github {
  padding-top: 10px;  
  padding-left: 30px;  
  padding-right: 30px;  
}

.panel-tabs {
  &lt;!-- color: #062A00; --&gt;
  color: #841F27;
  margin-top: 0px;  
  margin-bottom: 0px;  
  margin-left: 0px;  
  padding-bottom: 0px;  
}

.panel-tab {
  margin-top: 0px;  
  margin-bottom: 0px;  
  margin-left: 3px;  
  margin-right: 3px;  
  padding-top: 0px;  
  padding-bottom: 0px;  
}

.panelset .panel-tabs .panel-tab {
  min-height: 40px;
}

.remark-slide th {
  border-bottom: 1px solid #ddd;
}

.remark-slide thead {
  border-bottom: 0px;
}

.gt_footnote {
  padding: 2px;  
}

.remark-slide table {
  border-collapse: collapse;
}

.remark-slide tbody {
  border-bottom: 2px solid #666;
}


.important {
  background-color: lightpink;
  border: 2px solid blue;
  font-weight: bold;
} 

.remark-code {
  display: block;
  overflow-x: auto;
  padding: .5em;
  background: #ffe7e7;
} 

.hljs-github .hljs {
  background: #f2f2fd;
}

.remark-inline-code {
  padding-top: 0px;
  padding-bottom: 0px;
  background-color: #e6e6e6;
}

.r.hljs.remark-code.remark-inline-code{
  font-size: 0.9em
}

.left-full {
  width: 80%;
  height: 92%;
  float: left;
}

.left-code {
  width: 38%;
  height: 92%;
  float: left;
}

.right-plot {
  width: 60%;
  float: right;
  padding-left: 1%;
}

.left5 {
  width: 49%;
  height: 92%;
  float: left;
}

.right5 {
  width: 49%;
  float: right;
  padding-left: 1%;
}

.left3 {
  width: 29%;
  height: 92%;
  float: left;
}

.right7 {
  width: 69%;
  float: right;
  padding-left: 1%;
}

.left4 {
  width: 38%;
  height: 92%;
  float: left;
}

.right6 {
  width: 60%;
  float: right;
  padding-left: 1%;
}

ul li{
  margin: 7px;
}

ul, li{
  margin-left: 15px; 
  padding-left: 0px; 
}

ol li{
  margin: 7px;
}

ol, li{
  margin-left: 15px; 
  padding-left: 0px; 
}

&lt;/style&gt;

&lt;style type="text/css"&gt;
.content-box { 
    box-sizing: border-box;
    background-color: #e2e2e2;
}
.content-box-blue,
.content-box-gray,
.content-box-grey,
.content-box-army,
.content-box-green,
.content-box-purple,
.content-box-red,
.content-box-yellow {
  box-sizing: border-box;
  border-radius: 5px;
  margin: 0 0 10px;
  overflow: hidden;
  padding: 0px 5px 0px 5px;
  width: 100%;
}
.content-box-blue { background-color: #F0F8FF; }
.content-box-gray { background-color: #e2e2e2; }
.content-box-grey { background-color: #F5F5F5; }
.content-box-army { background-color: #737a36; }
.content-box-green { background-color: #d9edc2; }
.content-box-purple { background-color: #e2e2f9; }
.content-box-red { background-color: #ffcccc; }
.content-box-yellow { background-color: #fef5c4; }
.content-box-blue .remark-inline-code,
.content-box-blue .remark-inline-code,
.content-box-gray .remark-inline-code,
.content-box-grey .remark-inline-code,
.content-box-army .remark-inline-code,
.content-box-green .remark-inline-code,
.content-box-purple .remark-inline-code,
.content-box-red .remark-inline-code,
.content-box-yellow .remark-inline-code { 
  background: none;
}

.full-width {
    display: flex;
    width: 100%;
    flex: 1 1 auto;
}
&lt;/style&gt;


&lt;style type="text/css"&gt;
blockquote, .blockquote {
  display: block;
  margin-top: 0.1em;
  margin-bottom: 0.2em;
  margin-left: 5px;
  margin-right: 5px;
  border-left: solid 10px #0148A4;
  border-top: solid 2px #0148A4;
  border-bottom: solid 2px #0148A4;
  border-right: solid 2px #0148A4;
  box-shadow: 0 0 6px rgba(0,0,0,0.5);
  /* background-color: #e64626; */
  color: #e64626;
  padding: 0.5em;
  -moz-border-radius: 5px;
  -webkit-border-radius: 5px;
}

.blockquote p {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h1:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h2:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h3:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}
.blockquote &gt; h4:first-of-type {
  margin-top: 0px;
  margin-bottom: 5px;
}

.text-shadow {
  text-shadow: 0 0 4px #424242;
}
&lt;/style&gt;

&lt;style type="text/css"&gt;
/******************
 * Slide scrolling
 * (non-functional)
 * not sure if it is a good idea anyway
slides &gt; slide {
  overflow: scroll;
 padding: 5px 40px;
}
.scrollable-slide .remark-slide {
  height: 400px;
  overflow: scroll !important;
}
 ******************/

.scroll-box-8 {
  height:8em;
  overflow-y: scroll;
}
.scroll-box-10 {
  height:10em;
  overflow-y: scroll;
}
.scroll-box-12 {
  height:12em;
  overflow-y: scroll;
}
.scroll-box-14 {
  height:14em;
  overflow-y: scroll;
}
.scroll-box-16 {
  height:16em;
  overflow-y: scroll;
}
.scroll-box-18 {
  height:18em;
  overflow-y: scroll;
}
.scroll-box-20 {
  height:20em;
  overflow-y: scroll;
}
.scroll-box-24 {
  height:24em;
  overflow-y: scroll;
}
.scroll-box-30 {
  height:30em;
  overflow-y: scroll;
}
.scroll-output {
  height: 90%;
  overflow-y: scroll;
}

 
&lt;/style&gt;





# Table of contents

1. [Reshaping data](#reshaping)
2. [Merging datasets](#merging)

---
class: middle

# Learning objectives

The objectives of this chapter is to learn how to use the `tidyverse` package to 

+ reshape a dataset
+ merge multiple datasets 

---
class: inverse, center, middle
name: reshaping

# Reshaping

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# Long and wide formats

.left5[

## Long format

A single column representing a single variable 


```
##      state year yield
## 1   Kansas 2019   200
## 2   Kansas 2020   240
## 3 Nebraska 2019   210
## 4 Nebraska 2020   220
## 5     Iowa 2019   220
## 6     Iowa 2020   230
## 7 Illinois 2019   190
## 8 Illinois 2020   150
```
]

.right5[

## Wide format

Multiple column representing a single variable 


```
## # A tibble: 4 × 3
##   state    `2019` `2020`
##   &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 Kansas      200    240
## 2 Nebraska    210    220
## 3 Iowa        220    230
## 4 Illinois    190    150
```

Note: there is nothing in the dataset that tells you what the data values represent in the wide format.

]

---

# Long to wide 

.panelset[ 

&lt;!-- panel ends here --&gt;

.panel[.panel-name[prepare]

Create the following dataset in long format:


```r
yield_data_long &lt;- data.frame(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %&gt;% rep(each = 2),
  year = c(2019, 2020) %&gt;% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150)
  )
```

  ]

&lt;!-- panel ends here --&gt;
.panel[.panel-name[how and example]

.left5[

## How

To convert a long-formatted `data.frame` into a wide-formatted `data.frame`, you can use `pivot_wider()` function from the `tidyr` package.


```r
#--- NOT RUN ---#
pivot_wider(
  data, 
  names_from = variable 1, 
  values_from = variable 2
)
```

+ the value of `variable 1` becomes the name the new variables
+ the value of `variable 2` becomes the value of the new variables
]

.right5[

## Example


```r
yield_data_wide &lt;- pivot_wider(
  yield_data_long, 
  names_from = year, 
  values_from = yield
)

yield_data_wide
```

```
## # A tibble: 4 × 3
##   state    `2019` `2020`
##   &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;
## 1 Kansas      200    240
## 2 Nebraska    210    220
## 3 Iowa        220    230
## 4 Illinois    190    150
```

+ the value of `year` becomes the name the new variables
+ the value of `yield` becomes the value of the new variables

]

  ]

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[prefix]

You can append a character string to the new variable names. The previous example had `2019` and `2010` as the name of the new variables.


```r
yield_data_long %&gt;%
  pivot_wider(
    #--- let R know what the prefix is ---#
    names_prefix = "yield_",
    names_from = "year",
    values_from = "yield"
  )
```

```
## # A tibble: 4 × 3
##   state    yield_2019 yield_2020
##   &lt;chr&gt;         &lt;dbl&gt;      &lt;dbl&gt;
## 1 Kansas          200        240
## 2 Nebraska        210        220
## 3 Iowa            220        230
## 4 Illinois        190        150
```

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[multiple columns]

.left5[

## Prepare a dataset 

Create the following data in long format;


```r
yield_data_long &lt;- data.frame(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %&gt;% rep(each = 2),
  year = c(2019, 2020) %&gt;% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150),
  rainfall = c(14, 15, 15, 16, 20, 21, 24, 15)
  ) 
```


```
##      state year yield rainfall
## 1   Kansas 2019   200       14
## 2   Kansas 2020   240       15
## 3 Nebraska 2019   210       15
## 4 Nebraska 2020   220       16
## 5     Iowa 2019   220       20
## 6     Iowa 2020   230       21
## 7 Illinois 2019   190       24
## 8 Illinois 2020   150       15
```
]

.right5[

## Example

You can simply supply multiple variables to be made wide like this:


```r
yield_data_long %&gt;%  
  pivot_wider(
    names_from = "year",
    values_from = c("yield", "rainfall")
  )  
```

```
## # A tibble: 4 × 5
##   state    yield_2019 yield_2020 rainfall_2019 rainfall_2020
##   &lt;chr&gt;         &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;
## 1 Kansas          200        240            14            15
## 2 Nebraska        210        220            15            16
## 3 Iowa            220        230            20            21
## 4 Illinois        190        150            24            15
```
]
  ] 

  &lt;!-- panel ends here --&gt;
]

&lt;!-- panel set ends here --&gt;

---

# Wide to long

.panelset[ 

.panel[.panel-name[how]


.left5[

## How

To convert a long-formatted `data.frame` into a wide-formatted `data.frame`, you can use `pivot_longer()` function from the `tidyr` package.


```r
pivot_longer(
  data, 
  cols = x,
  names_to = y, 
  values_to = z 
)
```

+ `x`: list of the name of the columns to pivot into longer format
+ `y`: what the name of `x` represents
+ `z`: what the values stored in `x` represents
]

.right5[

## Example


```r
yield_data_wide %&gt;% 
  pivot_longer(
    - state, 
    names_to = "year", 
    values_to = "yield"
  )
```

```
## # A tibble: 8 × 3
##   state    year  yield
##   &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;
## 1 Kansas   2019    200
## 2 Kansas   2020    240
## 3 Nebraska 2019    210
## 4 Nebraska 2020    220
## 5 Iowa     2019    220
## 6 Iowa     2020    230
## 7 Illinois 2019    190
## 8 Illinois 2020    150
```

+ `x`: all the variables except `state`
+ `y`: "year"
+ `z`: "yield"

]

  ]

&lt;!-- panel ends here --&gt;


&lt;!-- panel ends here --&gt;

.panel[.panel-name[prefix]

You do not want `year_` in front of the year numbers in the new `year` variable? You can use the `names_prefix` option as follows:


```r
yield_data_wide %&gt;%  
  pivot_longer(
    - state,
    #--- let R know what the prefix is ---#
    names_prefix = "yield_",
    names_to = "year",
    values_to = "yield"
  )
```

```
## # A tibble: 8 × 3
##   state    year  yield
##   &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;
## 1 Kansas   2019    200
## 2 Kansas   2020    240
## 3 Nebraska 2019    210
## 4 Nebraska 2020    220
## 5 Iowa     2019    220
## 6 Iowa     2020    230
## 7 Illinois 2019    190
## 8 Illinois 2020    150
```

Notice `year` is character. Convert it to numeric using `as.numeric()` if you use is as a numeric variable.

  ] 

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;

---

# Wide to long: multiple sets of columns

.panelset[ 

.panel[.panel-name[Prep]


.left5[

## Long

Create the following dataset in the long format;


```r
yield_data_long &lt;- data.frame(
  state = c("Kansas", "Nebraska", "Iowa", "Illinois") %&gt;% rep(each = 2),
  year = c(2019, 2020) %&gt;% rep(4),
  yield = c(200, 240, 210, 220, 220, 230, 190, 150),
  rainfall = c(14, 15, 15, 16, 20, 21, 24, 15)
  ) 
```


```
##      state year yield rainfall
## 1   Kansas 2019   200       14
## 2   Kansas 2020   240       15
## 3 Nebraska 2019   210       15
## 4 Nebraska 2020   220       16
## 5     Iowa 2019   220       20
## 6     Iowa 2020   230       21
## 7 Illinois 2019   190       24
## 8 Illinois 2020   150       15
```

]

.right5[

## Wide

Convert the long dataset into the wide format: 


```r
yield_data_wide &lt;- yield_data_long %&gt;% 
  pivot_wider(
    names_from = year, 
    values_from = c(yield, rainfall)
  ) 
```


```
## # A tibble: 4 × 5
##   state    yield_2019 yield_2020 rainfall_2019 rainfall_2020
##   &lt;chr&gt;         &lt;dbl&gt;      &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;
## 1 Kansas          200        240            14            15
## 2 Nebraska        210        220            15            16
## 3 Iowa            220        230            20            21
## 4 Illinois        190        150            24            15
```

.red[Objective]: We would like to convert the wide data back to the original long data.

]

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[one-step?]

You cannot revert this data back to the original long-formatted data in one step. 


```r
yield_data_wide %&gt;% 
  pivot_longer(
    - state,
    names_to = "year",
    values_to = "yield"
  )
```

```
## # A tibble: 16 × 3
##    state    year          yield
##    &lt;chr&gt;    &lt;chr&gt;         &lt;dbl&gt;
##  1 Kansas   yield_2019      200
##  2 Kansas   yield_2020      240
##  3 Kansas   rainfall_2019    14
##  4 Kansas   rainfall_2020    15
##  5 Nebraska yield_2019      210
##  6 Nebraska yield_2020      220
##  7 Nebraska rainfall_2019    15
##  8 Nebraska rainfall_2020    16
##  9 Iowa     yield_2019      220
## 10 Iowa     yield_2020      230
## 11 Iowa     rainfall_2019    20
## 12 Iowa     rainfall_2020    21
## 13 Illinois yield_2019      190
## 14 Illinois yield_2020      150
## 15 Illinois rainfall_2019    24
## 16 Illinois rainfall_2020    15
```

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[separate()]

However, you take advantage of `dplyr::separate()` function, which separate a variable of type character by a user-specified separator into two variables in the dataset.


```r
#--- syntax ---#
separate(data, variable name, the name of variables, separator)  
```

.left5[

Before separation: 


```r
yield_data_wide %&gt;% 
  #--- select only state and yield variables ---#
  pivot_longer(
    - state,
    names_to = "type_year",
    values_to = "value"
  ) 
```

.scroll-box-12[

```
## # A tibble: 16 × 3
##    state    type_year     value
##    &lt;chr&gt;    &lt;chr&gt;         &lt;dbl&gt;
##  1 Kansas   yield_2019      200
##  2 Kansas   yield_2020      240
##  3 Kansas   rainfall_2019    14
##  4 Kansas   rainfall_2020    15
##  5 Nebraska yield_2019      210
##  6 Nebraska yield_2020      220
##  7 Nebraska rainfall_2019    15
##  8 Nebraska rainfall_2020    16
##  9 Iowa     yield_2019      220
## 10 Iowa     yield_2020      230
## 11 Iowa     rainfall_2019    20
## 12 Iowa     rainfall_2020    21
## 13 Illinois yield_2019      190
## 14 Illinois yield_2020      150
## 15 Illinois rainfall_2019    24
## 16 Illinois rainfall_2020    15
```
]

]

.right5[

After separation: 


```r
yield_data_wide %&gt;% 
  #--- select only state and yield variables ---#
  pivot_longer(
    - state,
    names_to = "type_year",
    values_to = "value"
* ) %&gt;% separate(type_year, c("type", "year"), sep = "_")
```

.scroll-box-12[

```
## # A tibble: 16 × 4
##    state    type     year  value
##    &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;
##  1 Kansas   yield    2019    200
##  2 Kansas   yield    2020    240
##  3 Kansas   rainfall 2019     14
##  4 Kansas   rainfall 2020     15
##  5 Nebraska yield    2019    210
##  6 Nebraska yield    2020    220
##  7 Nebraska rainfall 2019     15
##  8 Nebraska rainfall 2020     16
##  9 Iowa     yield    2019    220
## 10 Iowa     yield    2020    230
## 11 Iowa     rainfall 2019     20
## 12 Iowa     rainfall 2020     21
## 13 Illinois yield    2019    190
## 14 Illinois yield    2020    150
## 15 Illinois rainfall 2019     24
## 16 Illinois rainfall 2020     15
```
]
]
  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[three-step]

After separating `type_year` to `type` and `year`, all you have to do is to apply `pivot_wider()` to have the desired long-formatted data.


```r
yield_data_wide %&gt;% 
  #--- select only state and yield variables ---#
  pivot_longer(
    - state,
    names_to = "type_year",
    values_to = "value"
  ) %&gt;% 
  separate(type_year, c("type", "year"), sep = "_") %&gt;% 
* pivot_wider(
*   names_from = "type",
*   values_from = "value"
* )
```

```
## # A tibble: 8 × 4
##   state    year  yield rainfall
##   &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;    &lt;dbl&gt;
## 1 Kansas   2019    200       14
## 2 Kansas   2020    240       15
## 3 Nebraska 2019    210       15
## 4 Nebraska 2020    220       16
## 5 Iowa     2019    220       20
## 6 Iowa     2020    230       21
## 7 Illinois 2019    190       24
## 8 Illinois 2020    150       15
```

  ] 

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;


---

# Wide or long?

Suppose you are interested in estimating the following statistical model:

`$$corn yield = \beta_0 + \beta_1 R_{May}  + \beta_2 R_{June} + \beta_2 R_{July} + \beta_2 R_{August} + \beta_2 R_{September} + v$$`

where `\(R\)` refers to rainfall.

--

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

Then the following dataset


```
## # A tibble: 8 × 8
##   state     year yield R_May R_June R_July R_August R_September
##   &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;       &lt;dbl&gt;
## 1 Kansas    2019   200  5.13  11.7  14.5       7.67       14.9 
## 2 Kansas    2020   240  8.02   4.34  0.228    12.8        16.1 
## 3 Nebraska  2019   210  7.84  13.3  15.7       4.25       17.7 
## 4 Nebraska  2020   220 13.5   19.3  15.8       2.62        9.83
## 5 Iowa      2019   220 14.1   11.4   2.64     18.0         7.97
## 6 Iowa      2020   230 17.7    6.20  9.46      9.56        2.71
## 7 Illinois  2019   190 12.5   15.4   8.78      8.49        6.95
## 8 Illinois  2020   150  1.01  15.6  11.8      16.0        14.4
```

is in a &lt;span style="color:red"&gt; long &lt;/span&gt; format.

---

# Wide or long?

This is ".red[too long]" for your analysis. 


```
##        state year yield     month  rainfall
## 1     Kansas 2019   200       May 16.355186
## 1.1   Kansas 2019   200      June  5.514123
## 1.2   Kansas 2019   200      July  7.210913
## 1.3   Kansas 2019   200    August  1.081242
## 1.4   Kansas 2019   200 September  7.678872
## 2     Kansas 2020   240       May  6.860295
## 2.1   Kansas 2020   240      June  3.644038
## 2.2   Kansas 2020   240      July  2.148544
## 2.3   Kansas 2020   240    August  3.075467
## 2.4   Kansas 2020   240 September  8.605439
## 3   Nebraska 2019   210       May 19.559655
## 3.1 Nebraska 2019   210      June 11.477029
## 3.2 Nebraska 2019   210      July  6.583150
## 3.3 Nebraska 2019   210    August 18.549790
## 3.4 Nebraska 2019   210 September 12.895812
```

--

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

&lt;span style="color:red"&gt; Key point:&lt;/span&gt; Whether a dataset is wide or long is determined based on what you are doing with the dataset.

---

# Exercises 

.panelset[ 


.panel[.panel-name[Preparation]

Run the following code so you can use the `flights` dataset.

```r
library(nycflights13)
```
  ]

.panel[.panel-name[Exercise 1]

+ Using `flights` data, calculate the total number of flights by carrier-month, which is in the long format

+ Reshape the data into a wide format so that you have number of flights per month in columns 

Here is the output you are supposed to get if done correctly:


```
## # A tibble: 16 × 13
## # Groups:   carrier [16]
##    carrier month_1 month_2 month_3 month_4 month_5 month_6 month_7 month_8 month_9 month_10 month_11 month_12
##    &lt;chr&gt;     &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;   &lt;int&gt;    &lt;int&gt;    &lt;int&gt;    &lt;int&gt;
##  1 9E         1573    1459    1627    1511    1462    1437    1494    1456    1540     1673     1595     1633
##  2 AA         2794    2517    2787    2722    2803    2757    2882    2856    2614     2715     2577     2705
##  3 AS           62      56      62      60      62      60      62      62      60       62       52       54
##  4 B6         4427    4103    4772    4517    4576    4622    4984    4952    4291     4361     4289     4741
##  5 DL         3690    3444    4189    4092    4082    4126    4251    4318    3883     4093     3849     4093
##  6 EV         4171    3827    4726    4561    4817    4456    4641    4563    4725     4908     4471     4307
##  7 F9           59      49      57      57      58      55      58      55      58       57       61       61
##  8 FL          328     296     316     311     325     252     263     263     255      236      202      213
##  9 HA           31      28      31      30      31      30      31      31      25       21       25       28
## 10 MQ         2271    2044    2256    2211    2284    2178    2261    2263    2206     2228     2056     2139
## 11 OO            1      NA      NA      NA      NA       2      NA       4      20       NA        5       NA
## 12 UA         4637    4346    4971    5047    4960    4975    5066    5124    4694     5060     4854     4931
## 13 US         1602    1552    1721    1727    1785    1736    1786    1779    1698     1846     1699     1605
## 14 VX          316     271     303     466     496     480     489     489     453      472      451      476
## 15 WN          996     911     998     980    1006    1028    1076    1047    1010     1091     1033     1099
## 16 YV           46      48      18      38      49      49      81      65      42       66       49       50
```

  ]

.panel[.panel-name[Exercise 2]

+ Reshape the data back into the long format so that a single columns has all the flight number values 

Here is the output you are supposed to get if done correctly:


```
## # A tibble: 192 × 3
## # Groups:   carrier [16]
##    carrier month num_flights
##    &lt;chr&gt;   &lt;chr&gt;       &lt;int&gt;
##  1 9E      1            1573
##  2 9E      2            1459
##  3 9E      3            1627
##  4 9E      4            1511
##  5 9E      5            1462
##  6 9E      6            1437
##  7 9E      7            1494
##  8 9E      8            1456
##  9 9E      9            1540
## 10 9E      10           1673
## # … with 182 more rows
```

  ]

]


&lt;!-- 
#/*=================================================*/
#' # Data merge
#/*=================================================*/
--&gt;

---

class: inverse, center, middle
name: merging

# Merging multiple datasets

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---



# Merging multiple datasets

.panelset[ 

.panel[.panel-name[Motivation]

&lt;br&gt;

It is very common that you have data stored in separate files, and you need to combine them before you conduct any statistical analysis. 

For example, if you are interested in how crop price affects the supply of crops, you want to have price and production data in a single dataset. However, it may be that price and production data are stored in two separate files.

  ]

.panel[.panel-name[Match? 1]

&lt;br&gt;

Now suppose, you have collected price and production data for Lancaster and Douglas County from 2015 to 2016. 

Here is what the datasets look like (these are made-up numbers).

.left5[

```
##      price
## 1 2.213899
## 2 3.043525
## 3 4.928419
## 4 4.067760
```
]

.right5[

```
##      yield
## 1 193.0670
## 2 193.1554
## 3 247.0542
## 4 263.8076
```
]

&lt;br&gt;

Question: Can you merge the two?   

  ]

.panel[.panel-name[Match? 2]

&lt;br&gt;

Let's display one more variable from each of the datasets.

.left5[

```
##      price    county
## 1 2.213899 Lancaster
## 2 3.043525 Lancaster
## 3 4.928419   Douglas
## 4 4.067760   Douglas
```
]

.right5[

```
##      yield    county
## 1 193.0670 Lancaster
## 2 193.1554   Douglas
## 3 247.0542 Lancaster
## 4 263.8076   Douglas
```
]

&lt;br&gt;
&lt;br&gt;

Okay, great. At least we know which price and prod belong to which county! In other words, we know which price and prod belong to **who** (or **where**). 

Question: Can you merge the two now?   

  ]

.panel[.panel-name[Match? 3]

&lt;br&gt;

Let's display one more variable from each of the datasets.

.left5[

```
##      price    county year
## 1 2.213899 Lancaster 2015
## 2 3.043525 Lancaster 2016
## 3 4.928419   Douglas 2015
## 4 4.067760   Douglas 2016
```
]

.right5[

```
##      yield    county year
## 1 193.0670 Lancaster 2015
## 2 193.1554   Douglas 2015
## 3 247.0542 Lancaster 2016
## 4 263.8076   Douglas 2016
```
]

&lt;br&gt;
&lt;br&gt;

Question: Can you merge the two now?   

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

The variables that let you merge two datasets are called &lt;span style="color:blue"&gt; keys&lt;/span&gt;.

What are the keys here?

  ]

.panel[.panel-name[How]

+ You can use the `left_join()` function from the `dplyr` package to merge two datasets.

+ There are different types of join functions:
  * `right_join()` (you never need to use this one)
  * `inner_join()`
  * `full_join()`
  * `semi_join()`
  * `nest_join()`

+ But, most of the time, `left_join()` is sufficient. 

+ Try to learn other functions when you encounter a case where `left_join()` is not sufficient. Do not waster your time until then. 

  ]

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[left_join()]

**Syntax**


```r
#--- Syntax (NOT RUN) ---#
left_join(data_x, data_y, by = keys)  
```

**Rules to remember**

+ .blue[Rule 1]: It returns all rows from `data_x`, and all columns from `data_x` and `data_y`
+ .blue[Rule 2]: Rows in `data_x` with no match in `data_y` will have NA values in the new columns 
+ .blue[Rule 3]: If there are multiple matches between `data_x` and `data_y`, all combinations of the matches are returned

.content-box-red[Note: The order of datasets matter.]

  ]

]

---

# `left_join()` demonstration: 1 to 1

.panelset[ 

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Data prep]

Run the following code to run the merging demonstration later:


```r
N &lt;- 2
T &lt;- 2

set.seed(582374)

price_data &lt;- data.frame(
  price = runif(N * T, min = 2, max = 6),
  county = c(rep('Lancaster',2),rep('Douglas',2)),
  year = c(2015, 2016, 2015, 2016)
  )

yield_data &lt;- data.frame(
  yield = runif(N * T, min = 180, max = 280),
  county = c('Lancaster','Douglas','Lancaster','Douglas'),
  year = c(2015, 2015, 2016, 2016)
  )
```

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Demo 1]

The keys are `county` and `year`, so


```r
left_join(yield_data, price_data, by = c("county", "year"))  
```

```
##      yield    county year    price
## 1 193.0670 Lancaster 2015 2.213899
## 2 193.1554   Douglas 2015 4.928419
## 3 247.0542 Lancaster 2016 3.043525
## 4 263.8076   Douglas 2016 4.067760
```

Switching the two?


```r
left_join(price_data, yield_data, by = c("county", "year"))  
```

```
##      price    county year    yield
## 1 2.213899 Lancaster 2015 193.0670
## 2 3.043525 Lancaster 2016 247.0542
## 3 4.928419   Douglas 2015 193.1554
## 4 4.067760   Douglas 2016 263.8076
```

&lt;br&gt;

Note: In this instance, .red[which comes first does not matter] because all the individual rows in `yield_data` (left data) have exactly one match in `price_data` (right data) without fail, and vice versa.  

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Data prep 2]

Let's expand the `yield_data`:


```r
yield_data &lt;- data.frame(
  yield = runif(6, min = 180, max = 280),
  county = c("Lancaster", "Douglas", "Chase", "Lancaster", "Douglas", "Chase"),
  year = c(2015, 2015, 2015, 2016, 2016, 2016)
  ) 

yield_data
```

```
##      yield    county year
## 1 211.2672 Lancaster 2015
## 2 252.4351   Douglas 2015
## 3 270.2001     Chase 2015
## 4 228.9107 Lancaster 2016
## 5 186.0138   Douglas 2016
## 6 278.1366     Chase 2016
```

  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[Demo 2]

**`yield_data` on the right**:


```r
left_join(price_data, yield_data, by = c("county", "year"))  
```

```
##      price    county year    yield
## 1 2.213899 Lancaster 2015 211.2672
## 2 3.043525 Lancaster 2016 228.9107
## 3 4.928419   Douglas 2015 252.4351
## 4 4.067760   Douglas 2016 186.0138
```

**`yield_data` on the left**:


```r
left_join(yield_data, price_data, by = c("county", "year"))  
```

```
##      yield    county year    price
## 1 211.2672 Lancaster 2015 2.213899
## 2 252.4351   Douglas 2015 4.928419
## 3 270.2001     Chase 2015       NA
## 4 228.9107 Lancaster 2016 3.043525
## 5 186.0138   Douglas 2016 4.067760
## 6 278.1366     Chase 2016       NA
```

.red[Remember?]

+ .blue[Rule 1]: `left_join()` returns all rows from `data_x`, and all columns from `data_x` and `data_y`
+ .blue[Rule 2]: Rows in `data_x` with no match in `data_y` will have NA values in the new columns 
  ] 

  &lt;!-- panel ends here --&gt;

.panel[.panel-name[keeping all rows]

We saw in the previous slide having `price_data` (as `data_x`) and `yield_data` as (`data_y`), `left_join()` discarded rows in `yield_data` (`data_y`).

If you would like to keep unmatched rows in `data_y`, you can use `full_join()`.


```r
full_join(price_data, yield_data, by = c("county", "year"))  
```

```
##      price    county year    yield
## 1 2.213899 Lancaster 2015 211.2672
## 2 3.043525 Lancaster 2016 228.9107
## 3 4.928419   Douglas 2015 252.4351
## 4 4.067760   Douglas 2016 186.0138
## 5       NA     Chase 2015 270.2001
## 6       NA     Chase 2016 278.1366
```

  ] 

  &lt;!-- panel ends here --&gt;

]
&lt;!-- panel set ends here --&gt;

---

# `left_join` demonstration: 1 to m


.panelset[ 

.panel[.panel-name[Data prep]

Let's create a weather dataset where you have more than one observations per county-year:


```r
weather_data &lt;- data.frame(
  rainfall = 20 * runif(12),
  county = rep(c("Lancaster", "Douglas", "Chase"), each = 4),
  year = rep(c(2015, 2016), each = 2) %&gt;% rep(3),
  month = rep(c(4, 5), 6)
  ) 

weather_data
```

```
##      rainfall    county year month
## 1  13.0359987 Lancaster 2015     4
## 2  19.3492593 Lancaster 2015     5
## 3  13.2268623 Lancaster 2016     4
## 4  18.1639509 Lancaster 2016     5
## 5  14.0231417   Douglas 2015     4
## 6   0.3866028   Douglas 2015     5
## 7   0.0199757   Douglas 2016     4
## 8   2.6757665   Douglas 2016     5
## 9   7.9074977     Chase 2015     4
## 10  3.3164517     Chase 2015     5
## 11  8.3719617     Chase 2016     4
## 12 14.1974153     Chase 2016     5
```

  ]

&lt;!-- panel ends here --&gt;

.panel[.panel-name[Demo]


```r
left_join(yield_data, weather_data, by = c("county", "year"))
```

```
##       yield    county year   rainfall month
## 1  211.2672 Lancaster 2015 13.0359987     4
## 2  211.2672 Lancaster 2015 19.3492593     5
## 3  252.4351   Douglas 2015 14.0231417     4
## 4  252.4351   Douglas 2015  0.3866028     5
## 5  270.2001     Chase 2015  7.9074977     4
## 6  270.2001     Chase 2015  3.3164517     5
## 7  228.9107 Lancaster 2016 13.2268623     4
## 8  228.9107 Lancaster 2016 18.1639509     5
## 9  186.0138   Douglas 2016  0.0199757     4
## 10 186.0138   Douglas 2016  2.6757665     5
## 11 278.1366     Chase 2016  8.3719617     4
## 12 278.1366     Chase 2016 14.1974153     5
```

.red[Remember?] 

+ .blue[Rule 3]: If there are multiple matches between `data_x` and `data_y`, all combinations of the matches are returned

  ]

  &lt;!-- panel ends here --&gt;

]

&lt;!-- panel set ends here --&gt;


---

# Exercises

.panelset[ 

.panel[.panel-name[Preparation]

Create the following datasets and take a look at them to understand what's in them:

**Flights in January**:


```r
flights_Jan &lt;- flights %&gt;% 
  filter(month == 1) %&gt;% 
  select(month, day, dep_delay, origin)
```

**daily temperature in January**:


```r
daily_temp_Jan &lt;- weather %&gt;% 
  filter(month == 1) %&gt;% 
  group_by(origin, month, day) %&gt;% 
  summarize(temp = mean(temp))
```

**hourly temperature in January**:


```r
hourly_temp_Jan &lt;- weather %&gt;% 
  filter(month == 1) %&gt;% 
  select(origin, month, day, hour, temp) 
```

  ] 

.panel[.panel-name[Exercise 1]

+ You are interested in learning the impact of **daily** temperature on departure delay for the flights in January. To do so, you need to have the variables in a single dataset.  

+ Is this going to be a 1-to-1 matching or 1-to-m matching?

+ Merge `daily_temp_Jan` to `flights_Jan` using `left_join()`

&lt;br&gt;

Here is the output you are supposed to get if done correctly:


```
## # A tibble: 27,004 × 5
##    month   day dep_delay origin  temp
##    &lt;int&gt; &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;dbl&gt;
##  1     1     1         2 EWR     32.5
##  2     1     1         4 LGA     37.7
##  3     1     1         2 JFK     33.0
##  4     1     1        -1 JFK     33.0
##  5     1     1        -6 LGA     37.7
##  6     1     1        -4 EWR     32.5
##  7     1     1        -5 EWR     32.5
##  8     1     1        -3 LGA     37.7
##  9     1     1        -3 JFK     33.0
## 10     1     1        -2 LGA     37.7
## # … with 26,994 more rows
```

  ]

.panel[.panel-name[Exercise 2]

+ You are interested in learning the impact of **hourly** temperature on departure delay for the flights in January. To do so, you need to have them in a single dataset.  

+ Is this going to be a 1-to-1 matching or 1-to-m matching?

+ Merge `hourly_temp_Jan` to `flights_Jan` using `left_join()`

&lt;br&gt;

Here is the output you are supposed to get if done correctly:


```
## # A tibble: 151,660 × 6
##    month   day dep_delay origin  hour  temp
##    &lt;int&gt; &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt;
##  1     1     1         2 EWR       16  37.0
##  2     1     1         2 EWR       18  34.0
##  3     1     1         2 EWR       21  30.0
##  4     1     1         2 EWR       22  28.9
##  5     1     1         4 LGA        1  39.9
##  6     1     1         4 LGA        2  41  
##  7     1     1         4 LGA        3  41  
##  8     1     1         4 LGA        4  41  
##  9     1     1         4 LGA        5  39.9
## 10     1     1         4 LGA        6  39.9
## # … with 151,650 more rows
```

Each flight (single row in `flights_Jan`) now has multiple rows. Was this expected? 

  ]

]

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
